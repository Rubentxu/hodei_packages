package dev.rubentxu.hodei.packages.application.auth

import dev.rubentxu.hodei.packages.application.auth.AuthServiceError.AdminAlreadyExists
import dev.rubentxu.hodei.packages.application.security.PasswordHasher
import dev.rubentxu.hodei.packages.domain.model.AdminUser
import dev.rubentxu.hodei.packages.domain.repository.UserRepository
import io.mockk.coEvery
import java.time.Instant
import java.util.UUID
import io.mockk.coVerify
import io.mockk.mockk
import dev.rubentxu.hodei.packages.application.shared.Result // For mocking createAdmin return type
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Test
import io.mockk.slot

class AuthServiceImplTest {
    private val userRepository = mockk<UserRepository>()
    private val passwordHasher = mockk<PasswordHasher>()
    private val authService = AuthServiceImpl(userRepository, passwordHasher)

    @Test
    fun `testRegisterFirstAdmin success when no admin exists and conditions met`() = runTest {
        val command = RegisterAdminCommand(
            username = "testuser",
            email = "test@example.com",
            password = "password123"
        )
        val hashedPassword = "hashedPassword123"
        val capturedAdminUserSlot = slot<AdminUser>()
        // Simulate the AdminUser instance that would be returned by a successful save
        val returnedAdminUser = AdminUser(
            id = UUID.randomUUID(), // ID is usually generated by the database/repository
            username = command.username,
            email = command.email,
            hashedPassword = hashedPassword,
            isActive = true,
            createdAt = Instant.now(), // Timestamps are usually set by the database/repository
            updatedAt = Instant.now(),
            lastAccess = null
        )

        coEvery { userRepository.existsAdmin() } returns false
        coEvery { passwordHasher.hash(command.password) } returns hashedPassword
        coEvery { userRepository.save(capture(capturedAdminUserSlot)) } returns returnedAdminUser

        val result = authService.registerFirstAdmin(command)

        assertTrue(result.isSuccess, "Expected success, but got failure: ${result.errorOrNull()}")
        val authResult = result.getOrNull()
        assertNotNull(authResult, "AuthenticationResult should not be null on success")
        assertEquals(command.username, authResult?.username)
        assertEquals(command.email, authResult?.email)
        assertEquals("mock-token", authResult?.token) // Assuming mock-token is still the expected token for now

        coVerify(exactly = 1) { userRepository.existsAdmin() }
        coVerify(exactly = 1) { passwordHasher.hash(command.password) }
        coVerify(exactly = 1) { userRepository.save(any()) } // Verifying with any() or capturedAdminUserSlot.captured

        val savedUser = capturedAdminUserSlot.captured
        assertEquals(command.username, savedUser.username)
        assertEquals(command.email, savedUser.email)
        assertEquals(hashedPassword, savedUser.hashedPassword)
        assertTrue(savedUser.isActive)
    }

    @Test
    fun `testRegisterFirstAdmin failure when admin already exists`() =
        runTest {
            coEvery { userRepository.existsAdmin() } returns true

            val result =
                authService.registerFirstAdmin(
                    RegisterAdminCommand(
                        username = "testuser",
                        email = "test@example.com",
                        password = "password123",
                    ),
                )

            assertTrue(result.isFailure)
            assertEquals(AdminAlreadyExists, result.errorOrNull())

            coVerify(exactly = 1) { userRepository.existsAdmin() }
            coVerify(exactly = 0) { passwordHasher.hash(any()) }
            coVerify(exactly = 0) { userRepository.save(any()) }
        }

    @Test
    fun `registerFirstAdmin failure when username is invalid`() = runTest {
        // TODO: Implement test: Given invalid username in command
        // When registerFirstAdmin is called
        // Then should return Result.Failure with AuthServiceError.ValidationFailed (or specific validation error)
        // And no repository or hasher methods should be called
        val command = RegisterAdminCommand(
            username = "", // Invalid username
            email = "test@example.com",
            password = "password123"
        )
        // coEvery { userRepository.existsAdmin() } returns false // Should not be called if validation fails early

        val result = authService.registerFirstAdmin(command)

        assertTrue(result.isFailure, "Expected failure for invalid username")
        assertEquals(AuthServiceError.ValidationFailed("Username cannot be blank"), result.errorOrNull())

        coVerify(exactly = 0) { userRepository.existsAdmin() }
        coVerify(exactly = 0) { passwordHasher.hash(any()) }
        coVerify(exactly = 0) { userRepository.save(any()) }
    }

    @Test
    fun `registerFirstAdmin failure when email is invalid`() = runTest {
        // TODO: Implement test: Given invalid email in command
        // When registerFirstAdmin is called
        // Then should return Result.Failure with AuthServiceError.ValidationFailed
        // And no repository or hasher methods should be called
        val command = RegisterAdminCommand(
            username = "testuser",
            email = "invalid-email", // Invalid email
            password = "password123"
        )

        val result = authService.registerFirstAdmin(command)

        assertTrue(result.isFailure, "Expected failure for invalid email")
        assertEquals(AuthServiceError.ValidationFailed("Invalid email format"), result.errorOrNull())

        coVerify(exactly = 0) { userRepository.existsAdmin() }
        coVerify(exactly = 0) { passwordHasher.hash(any()) }
        coVerify(exactly = 0) { userRepository.save(any()) }
    }

    @Test
    fun `registerFirstAdmin failure when password is invalid`() = runTest {
        // TODO: Implement test: Given invalid password in command
        // When registerFirstAdmin is called
        // Then should return Result.Failure with AuthServiceError.ValidationFailed
        // And no repository or hasher methods should be called
        val command = RegisterAdminCommand(
            username = "testuser",
            email = "test@example.com",
            password = "short" // Invalid password
        )

        val result = authService.registerFirstAdmin(command)

        assertTrue(result.isFailure, "Expected failure for invalid password")
        assertEquals(AuthServiceError.ValidationFailed("Password must be at least 8 characters"), result.errorOrNull())

        coVerify(exactly = 0) { userRepository.existsAdmin() }
        coVerify(exactly = 0) { passwordHasher.hash(any()) }
        coVerify(exactly = 0) { userRepository.save(any()) }
    }

    @Test
    fun `registerFirstAdmin failure when userRepository existsAdmin throws exception`() = runTest {
        // TODO: Implement test: Given userRepository.existsAdmin() throws exception
        // When registerFirstAdmin is called
        // Then should return Result.Failure with AuthServiceError.UnexpectedError
        val command = RegisterAdminCommand("testuser", "test@example.com", "password123")
        val exception = RuntimeException("DB error")
        coEvery { userRepository.existsAdmin() } throws exception

        val result = authService.registerFirstAdmin(command)

        assertTrue(result.isFailure, "Expected failure when existsAdmin throws exception")
        assertEquals(AuthServiceError.UnexpectedError(exception.message ?: "Unknown error", exception), result.errorOrNull())

        coVerify(exactly = 1) { userRepository.existsAdmin() }
        coVerify(exactly = 0) { passwordHasher.hash(any()) }
        coVerify(exactly = 0) { userRepository.save(any()) }
    }

    @Test
    fun `registerFirstAdmin failure when passwordHasher throws exception`() = runTest {
        // TODO: Implement test: Given passwordHasher.hash() throws exception
        // When registerFirstAdmin is called
        // Then should return Result.Failure with AuthServiceError.UnexpectedError
        val command = RegisterAdminCommand("testuser", "test@example.com", "password123")
        val exception = RuntimeException("Hashing error")
        coEvery { userRepository.existsAdmin() } returns false
        coEvery { passwordHasher.hash(command.password) } throws exception

        val result = authService.registerFirstAdmin(command)

        assertTrue(result.isFailure, "Expected failure when passwordHasher throws exception")
        assertEquals(AuthServiceError.UnexpectedError(exception.message ?: "Unknown error", exception), result.errorOrNull())

        coVerify(exactly = 1) { userRepository.existsAdmin() }
        coVerify(exactly = 1) { passwordHasher.hash(command.password) }
        coVerify(exactly = 0) { userRepository.save(any()) }
    }

    @Test
    fun `registerFirstAdmin failure when userRepository save throws exception`() = runTest {
        // TODO: Implement test: Given userRepository.save() throws exception
        // When registerFirstAdmin is called
        // Then should return Result.Failure with AuthServiceError.UnexpectedError
        val command = RegisterAdminCommand("testuser", "test@example.com", "password123")
        val hashedPassword = "hashedPassword123"
        val exception = RuntimeException("DB save error")

        coEvery { userRepository.existsAdmin() } returns false
        coEvery { passwordHasher.hash(command.password) } returns hashedPassword
        coEvery { userRepository.save(any()) } throws exception

        val result = authService.registerFirstAdmin(command)

        assertTrue(result.isFailure, "Expected failure when userRepository save throws exception")
        assertEquals(AuthServiceError.UnexpectedError(exception.message ?: "Unknown error", exception), result.errorOrNull())

        coVerify(exactly = 1) { userRepository.existsAdmin() }
        coVerify(exactly = 1) { passwordHasher.hash(command.password) }
        coVerify(exactly = 1) { userRepository.save(any()) }
    }
}
