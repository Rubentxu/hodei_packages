package dev.rubentxu.hodei.packages.domain.integrityverification.sbom.service


import dev.rubentxu.hodei.packages.domain.common.events.EventPublisher
import dev.rubentxu.hodei.packages.domain.integrityverification.sbom.events.SbomGenerationCompletedEvent
import dev.rubentxu.hodei.packages.domain.integrityverification.sbom.events.SbomGenerationFailedEvent
import dev.rubentxu.hodei.packages.domain.integrityverification.sbom.events.SbomGenerationStartedEvent
import dev.rubentxu.hodei.packages.domain.integrityverification.sbom.model.SbomComponent
import dev.rubentxu.hodei.packages.domain.integrityverification.sbom.model.SbomDocument
import dev.rubentxu.hodei.packages.domain.integrityverification.sbom.model.SbomFormat
import dev.rubentxu.hodei.packages.domain.integrityverification.sbom.ports.SbomRepository

import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.collections.shouldContainExactlyInAnyOrder
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.types.shouldBeInstanceOf
import io.mockk.*

/**
 * Unit tests for [SbomGenerator].
 * These tests verify the behavior of the SbomGenerator, particularly its interaction
 * with the EventPublisher and SbomRepository, and the overall success/failure flow.
 * By default, these tests will use the InternalSbomGenerator via the SbomGeneratorFactory.
 */
class SbomGeneratorTest : StringSpec({
    val mockEventPublisher = mockk<EventPublisher>(relaxed = true)
    val mockSbomRepository = mockk<SbomRepository>()
    // This artifactId is for test reference, the actual one is generated by the service
    val testReferenceArtifactId = "test-artifact-123"
    val format = SbomFormat.CYCLONE_DX

    // SbomGenerator will use InternalSbomGenerator by default as sbomToolPath is null
    val sbomGenerator = SbomGenerator(mockEventPublisher, mockSbomRepository)

    // Slot to capture the dynamically generated artifactId
    val artifactIdSlot = slot<String>()

    beforeEach {
        clearMocks(mockEventPublisher, mockSbomRepository)
        // Capture artifactId from SbomGenerationStartedEvent using a MockK matcher
        coEvery { mockEventPublisher.publish(match(SbomGenerationStartedEventMatcher(artifactIdSlot))) } coAnswers { Result.success(Unit) }
    }

    "generate SBOM successfully should extract components, save document, and publish events" {
        val artifactContent = """
            {
                "name": "test-package",
                "version": "1.0.0",
                "dependencies": {
                    "dependency1": "1.2.3",
                    "dependency2": "4.5.6"
                }
            }
        """.trimIndent().toByteArray()

        val expectedMainComponent = SbomComponent(name = "test-package", version = "1.0.0", type = "library")
        val expectedDep1 = SbomComponent(name = "dependency1", version = "1.2.3", type = "library")
        val expectedDep2 = SbomComponent(name = "dependency2", version = "4.5.6", type = "library")

        // Usar un objeto real de SbomDocument
        var capturedArtifactId: String? = null
        coEvery { mockSbomRepository.save(any()) } answers {
            val actualDoc = arg<SbomDocument>(0)
            capturedArtifactId = actualDoc.artifactId
            Result.success(
                SbomDocument(
                    artifactId = actualDoc.artifactId,
                    format = actualDoc.format,
                    specVersion = actualDoc.specVersion,
                    components = actualDoc.components,
                    creationTime = actualDoc.creationTime
                )
            )
        }

        // Execute the method under test
        val result = sbomGenerator.generate(artifactContent, format)

        // Verify the result
        result.isSuccess shouldBe true
        val returnedSbomDoc = result.getOrNull()
        returnedSbomDoc shouldNotBe null
        returnedSbomDoc!!.artifactId shouldBe artifactIdSlot.captured // Verify captured artifactId
        returnedSbomDoc.format shouldBe format
        returnedSbomDoc.specVersion shouldBe "1.4" // As set by InternalSbomGenerator
        returnedSbomDoc.components shouldContainExactlyInAnyOrder listOf(expectedMainComponent, expectedDep1, expectedDep2)

        // Verify event publishing order and content
        coVerifyOrder {
            mockEventPublisher.publish(match<SbomGenerationStartedEvent> {
                it.artifactId == artifactIdSlot.captured && it.format == format
            })
            mockSbomRepository.save(match<SbomDocument> {
                it.artifactId == artifactIdSlot.captured &&
                it.format == format &&
                it.components.size == 3
            })
            mockEventPublisher.publish(match<SbomGenerationCompletedEvent> {
                it.artifactId == artifactIdSlot.captured &&
                it.sbomDocument.artifactId == artifactIdSlot.captured
            })
        }
        // Ensure no failure event was published
        coVerify(exactly = 0) { mockEventPublisher.publish(ofType<SbomGenerationFailedEvent>()) }
    }

    "generate SBOM should handle repository save failure and publish failure event" {
        val artifactContent = """
            {
                "name": "test-package",
                "version": "1.0.0"
            }
        """.trimIndent().toByteArray()
        val errorMessage = "Failed to save SBOM document"
        val exception = RuntimeException(errorMessage)

        // Configure repository to fail on save
        coEvery { mockSbomRepository.save(any()) } returns Result.failure(exception)

        // Execute the method under test
        val result = sbomGenerator.generate(artifactContent, format)

        // Verify the result is a failure
        result.isFailure shouldBe true
        result.exceptionOrNull().shouldBeInstanceOf<RuntimeException>()
        result.exceptionOrNull()?.message shouldBe errorMessage

        // Verify event publishing order and content
        coVerifyOrder {
            mockEventPublisher.publish(match<SbomGenerationStartedEvent> {
                it.artifactId == artifactIdSlot.captured && it.format == format
            })
            mockSbomRepository.save(any()) // save was called
            mockEventPublisher.publish(match<SbomGenerationFailedEvent> {
                it.artifactId == artifactIdSlot.captured &&
                it.format == format &&
                it.errorMessage == errorMessage
            })
        }
        // Ensure no completion event was published
        coVerify(exactly = 0) { mockEventPublisher.publish(ofType<SbomGenerationCompletedEvent>()) }
    }

    "generate SBOM should handle internal processing failure (e.g., bad content) and publish failure event" {
        // This content is intentionally malformed JSON to cause an error during extractComponents
        val malformedArtifactContent = "{ name: \"test-package\", ".toByteArray()
        // The new error message will be from the IllegalArgumentException thrown by extractComponents
        val expectedErrorMessageContains = "Failed to parse artifact content as JSON" 

        // The repository save should not be called in this case
        coEvery { mockSbomRepository.save(any()) } returns Result.success(mockk())


        // Execute the method under test
        val result = sbomGenerator.generate(malformedArtifactContent, format)

        // Verify the result is a failure
        result.isFailure shouldBe true
        val actualException = result.exceptionOrNull()
        actualException.shouldBeInstanceOf<IllegalArgumentException>() // Updated expected exception type

        // Verify event publishing order and content
        coVerifyOrder {
            mockEventPublisher.publish(match<SbomGenerationStartedEvent> { // This uses the lambda matcher, which is fine
                it.artifactId == artifactIdSlot.captured && it.format == format
            })
            // sbomRepository.save should NOT be called
            mockEventPublisher.publish(match<SbomGenerationFailedEvent> {
                it.artifactId == artifactIdSlot.captured &&
                it.format == format &&
                (it.errorMessage.contains(expectedErrorMessageContains)) // Check for the new error message
            })
        }
        coVerify(exactly = 0) { mockSbomRepository.save(any()) }
        coVerify(exactly = 0) { mockEventPublisher.publish(ofType<SbomGenerationCompletedEvent>()) }
    }
})

// Custom MockK matcher for SbomGenerationStartedEvent that also captures the artifactId.
private class SbomGenerationStartedEventMatcher(
    private val artifactIdSlotToCaptureInto: CapturingSlot<String>
) : Matcher<Any> { // Cambia a Matcher<Any> para evitar ClassCastException

    override fun match(arg: Any?): Boolean {
        // Solo captura si es del tipo correcto
        if (arg is SbomGenerationStartedEvent) {
            artifactIdSlotToCaptureInto.captured = arg.artifactId
            return true
        }
        return false
    }

    override fun toString(): String = "SbomGenerationStartedEventMatcher(captures artifactId into slot)"
}